--- 
layout: home
title: test 
---




<h2>PHP Client Class</h2>

<p>
The SAPO_Broker class abstracts all the low-level complexity of the SAPO Broker and gives the developer a simple to use high-level API to build event consumers and producers.
</p>

<p>
It will work with at least PHP 4.3.0 but PHP >5.2.x is recomended. Minimum PHP requirements are the  mbstring extension and  streams support for socket communications. Most standard PHP distributions have these.
</p>

<p>
This class is event driven and provides the  main loop for your program. Running an event consumer with this class requires only 3 simple steps:
</p>

<ol>
<li>Initializing the class $broker=new SAPO_Broker;</li>
<li>Subscribing the desired event topics $broker->subscribe(...);</li>
<li>Running the main loop $broker->consumer();</li>
</ol>

<p>A very simple (but complete) consumer can look like this:</p>

<pre class="prettyprint">
include('classes/broker.php');
$broker=new SAPO_Broker;
$broker->subscribe('/sapo/homepage/visits',NULL,"processEvent");
$broker->consumer();

function processEvent($payload) {
  echo "Someone has visited the Homepage\n";
  echo $payload."\n";
  }
</pre>

<p>
Lets look into each step in detail now:
</p>

<h3>Class initialization</h3>

<p>
The first thing to do is initializing the class. You can do this at any stage in your code. It as simple as:
</p>

<pre class="prettyprint">
$broker=new SAPO_Broker;
</pre>

<h3>Initialization options</h3>

<p>
When initializing the SAPO_Broker class, you can provide a series of parameters to tune your preferences. All of them are optional. These are:
</p>

<h4>server</h4>

<p>
Defines the IP address of the broker agent to which connect.
</p>

<p>
If this parameter is not supplied then a series of tests are conducted to provide auto-discovery for the nearest agent:
</p>

<ol>
<li>The environment variable SAPO_BROKER_SERVER is checked. If it exists, then it will be used.</li>
<li>Tries to connect to the localhost (127.0.0.1) IP. Will be used if successful.</li>
<li>Check for the existence of a /etc/world_map.xml file. Picks a random agent from it. Tries to connect. Uses it if successful (otherwise repeats the step 2 more times).</li>
<li>Uses the last resort DNS name broker.bk.sapo.pt which is a round robin record to a few agents.</li>
</ol>

<h4>port</h4>

<p>
TCP port in which the Broker is listening for clients. Default is 3332.
</p>

<h4>debug</h4>

<p>
Setting debug to true will output a lot of useful information for the developer. Default is false.
</p>

<h4>timeout</h4>

<p>
Maximum time (in seconds) for inactivity (sent or received data) after which the connection drops and reconnects. Default is 5 minutes.
</p>

<h4>locale</h4>

<p>
 Locale setting used in multibyte functions. Default is pt_PT.
</p>

<h4>force_expat</h4>

<p>Force the XML parser to use  expat. Default is false.</p>

<h4>force_dom</h4>

<p>Force the XML parser to use native PHP  DOM support. Default is false.</p>

<p>If neither force_dom or force_dom are specified (default behavior), the DOM parser has priority and will be used if available.</p>

<p>The parameters are passed inside an array structure like this:</p>


<pre class="prettyprint">
$opts=array('debug'=>TRUE
            'server'=>'10.135.0.1'
            'force_dom'=>TRUE);

$broker=new SAPO_Broker($opts);
</pre>

<h3>Subscribing a topic</h3>

<p>
You may subscribe as many topics as you wish before entering the main loop. For each subscription you must provide the topic name, the callback function to handle the incoming events from that topic, and an optional array of parameters the the subscription. This is the syntax:
</p>

<pre class="prettyprint">
$broker->subscribe('/topic/path',$opts,"callbackUserFunc");
</pre>

<h3>Topic name</h3>

<p>
A topic is a namespace in the form of a filesystem path. Each topic is related to certain kind of events. Topic producers are advised to follow a logical hierarchy like this /unit/platform/kind/subkind/...
</p>

<p>
For instance this topic /sapo/blogs/activity/post sends events each time a user from the  SAPO Blogs posts an article.
</p>

<p>
And this /sapo/blogs/activity/session sends events each time a user logs on.
</p>

<p>
You can also subscribe multiple topics with only one subscription using  regular expressions. For instance, subscribing this /sapo/blogs/activity/.* will get you events from both topics above, plus anything after /sapo/blogs/activity/...
</p>

<h3>Subscription options</h3>

<h4>destination_type</h4>

<p>There are 3 supported types of destination:</p>

<ol>
<li>TOPIC (default)</li>
<li>QUEUE</li>
<li>TOPIC_AS_QUEUE</li>
</ol>

<p>
<b>TOPIC</b> type topics are fire and forget events. The produced events are broadcasted across the cloud and one or more consumers can read those events in parallel. Events can be missed from the consumers if there is a problem. Think an FM radio station and many listeners tuned in. This is actually the most common use-case and the default setting.
</p>

<p>
<b>QUEUE</b> type topics implement true persistent and secure queues across the cloud. Each produced event is guaranteed only to be read by one consumer and leaves the queue only when it's acknowledged by both ends. Use cases for queues are online payment events, a registration process, etc.
</p>

<p><b>TOPIC_AS_QUEUE</b> is very similar to the above but the events are produced as normal TOPIC types and fired and forgotten, only the consumers act like QUEUEers. This is very useful for load balancing scenarios. For instance suppose you have a normal TOPIC type with loads of messages per second which you need to process into a SQL database. You can have 2 or more TOPIC_AS_QUEUE subscribed consumers processing those events and the cloud guarantees the equal distribution of unique events to each, so in practice you're distributing the topic load to N consumers. As there's no acknowledge in the producer you can also mix TOPIC with TOPIC_AS_QUEUE subscriptions, the cloud will handle this just fine.
</p>

<h3>Callback function</h3>

<p>This is the name of the function used to receive the payload from the events. This function will be called by the main loop each time a new event arrives and it's supposed to process the payload in any way to user wishes.
</p>

<p>
If the callback function is inside a class you can use this syntax:
</p>

<pre class="prettyprint">
$broker->subscribe('/topic/path',$opts,array("Class_Name","callbackUserFunc"));
</pre>

<p>
Each time the function is called, 3 parameters are passed to it's arguments, namely:
</p>

<pre class="prettyprint">
function callbackFunc($payload,$topic,$message_id) {};
</pre>

<h4>payload</h4>

<p>
This includes the event payload which can be pretty much anything the producer defines, an XML message or plain text.
</p>

<h4>topic</h4>

<p>
The topic to which the event refers. This is useful if you're using wildcard subscriptions.
</p>

<h4>message_id</h4>

<p>
Each event has a MessageId. This is it.
</p>

<h3>Advanced usage</h3>

<h4>Periodic calls</h4>

<p>
For flexibility you can add your own periodic calls to the main loop. They will be executed regardless of the incoming traffic in your subscribed topics. This allows more complex programs to be written with the SAPO_Broker APIs.
</p>

<p>
Just call add_callback as many times as you wish before the main loop, like this:
</p>

<pre class="prettyprint">
$broker->add_callback(array("sec"=>5),"periodicCall");
</pre>

<p>
Again you can use the array("Class_Name","periodicCall") syntax if your function lives inside a class.
</p>

<p>
In the input arguments you can use sec (seconds) or usec (microseconds) to define the time interval for which the function is executed.
</p>

<p>
Here's a complete code example for better understanding.
</p>

<h3>Examples</h3>

<p>
You can look at some examples <a href="https://github.com/sapo/sapo-broker/tree/master/clients/php-component/examples">here</a>.
</p>
